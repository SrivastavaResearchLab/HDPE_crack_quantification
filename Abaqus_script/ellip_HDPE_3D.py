"""
Python script to generate penny-shaped cracks within a 40 X 40 X 19 mm steel block
There are four parameters:
 - Short axis
 - Long axis (size)
 - Location (depth)
 - Orientation

There are in total three output files generated by this python script
1 - Ellip_crack.csv contains simulation data in a time-amplitude form
2 - Ellip_crack_info.csv contains all the crack info that correspond to the above simulation
3 - Ellip_failed_simulation.txt contains information about all the failed simulations

Written by Sijun Niu, November 10th 2020
"""
############################################################################################################
# -*- coding: mbcs -*-

"""Import modules"""
from part import *
from material import *
from section import *
from assembly import *
from step import *
from interaction import *
from load import *
from mesh import *
from optimization import *
from job import *
from sketch import *
from visualization import *
from connectorBehavior import *
from odbAccess import *
import sys
import os
import random
import math
import xlsxwriter
import time

"""This command uses findAt functions to locate objects such as faces and cells, instead of getSequencyFromMask"""
session.journalOptions.setValues(replayGeometry=COORDINATE, recoverGeometry=COORDINATE)

"""Activate the corresponding properties to be used in the simulation"""
# Set the flag to True to activate
crack_short_axis = False
crack_long_axis = False
crack_depth = False
crack_orientation = False

# Set the flag to True if odb is not needed
remove_odb = True

"""Remove the old files"""
try:
	os.remove('ellip_HDPE/Ellip_HDPE.xlsx')
except WindowsError:
	pass
try:
	os.remove('ellip_HDPE/Ellip_HDPE_info.xlsx')
except WindowsError:
	pass

"""Create workbooks to store simulation data"""
wb1 = xlsxwriter.Workbook('ellip_HDPE/Ellip_HDPE.xlsx')
wb2 = xlsxwriter.Workbook('ellip_HDPE/Ellip_HDPE_info.xlsx')
sheet1 = wb1.add_worksheet()
sheet2 = wb2.add_worksheet()

"""Set the parameters of the simulation"""
# Number of simulation
num_of_simulation = 1

# Default geometric parameters
default_short_axis = 0.00025
default_long_axis = 0.0015
default_depth = 0.009
default_angle = 0.0

# Range for the parameters if True flag is set
short_axis_min = 0.0002
short_axis_max = 0.0005
long_axis_min = 0.0005
long_axis_max = 0.003
depth_min = 0.003
depth_max = 0.011
angle_min = 0.0
angle_max = math.pi/2.0 * 0.99

# Possible depth location
possible_depth = [0.003, 0.006, 0.009]

# Pipe thickness
pipe_t = 0.0127

# Partition size for inner box, outer box and probe size
part_in = 0.001
probe_radius = 0.00635

# Mesh size near the crack edges
mesh_size_fine = 0.0001

# Ordered mesh size outside the partition for elliptical crack
mesh_size_general = 0.0002

# Coarse mesh far from the elliptical crack
mesh_size_coarse = 0.002

# Total time and user-fixed time increment
total_time = 2.0e-05
time_increment = 1e-08
sampling_number = total_time / time_increment

# Material parameters of the plate [SI unit]
young_modulus = 970000000.0
poisson_ratio = 0.43
mat_density = 954.0

# The number of evenly spaced data
space_number = 41

"""Lists to be used later"""
# List to store failed simulation info
failed_mesh = []
failed_earlystop = []

# Set default crack information if not otherwise specified in the loop
if crack_short_axis:
	short_axes = [random.uniform(short_axis_min, short_axis_max) for i in range(num_of_simulation)]
else:
	short_axes = [default_short_axis for i in range(num_of_simulation)]

if crack_long_axis:
	long_axes = [random.uniform(long_axis_min, long_axis_max) for i in range(num_of_simulation)]
	#long_axes = [long_axis_min + i * (long_axis_max - long_axis_min) / (space_number - 1) for i in range(space_number)]
else:
	long_axes = [default_long_axis for i in range(num_of_simulation)]

if crack_depth:
	depths = [random.uniform(depth_min, depth_max) for i in range(num_of_simulation)]
	#depths = [depth_min + i * (depth_max - depth_min) / (space_number - 1) for i in range(space_number)]
	#depths = [possible_depth[random.randint(0,2)] for i in range(num_of_simulation)]
else:
	depths = [default_depth for i in range(num_of_simulation)]

if crack_orientation:
	angles = [random.uniform(angle_min, angle_max) for i in range(num_of_simulation)]
	#angles = [angle_min + i * (angle_max - angle_min) / (space_number - 1) for i in range(space_number)]
else:
	angles = [default_angle for i in range(num_of_simulation)]

"""Initiate the while loop"""
current_index = 1
loop_index = 0
failure_flag = 0
trial_index = 0
max_trial = 0

while current_index <= num_of_simulation:

	if not failure_flag:
		current_short_axis = short_axes[current_index - 1]
		current_long_axis = long_axes[current_index - 1]
		current_depth = depths[current_index - 1]
		current_angle = angles[current_index - 1]

		"""To create even spaced data"""
		#current_long_axis = long_axes[loop_index]
		#current_depth = depths[(current_index - 1) % space_number]

	else:
		trial_index = trial_index + 1
		current_short_axis = short_axes[current_index - 1]
		current_long_axis = long_axes[loop_index] - crack_long_axis * trial_index * 0.01 * long_axes[loop_index]
		current_depth = depths[current_index - 1]
		current_angle = angles[(current_index - 1) % space_number] - crack_orientation * trial_index * 0.01 * angles[(current_index - 1) % space_number]

	## Create 3D part
	mdb.models['Model-1'].ConstrainedSketch(name='__profile__', sheetSize=0.5)
	mdb.models['Model-1'].sketches['__profile__'].rectangle(point1=(0.0, 0.0),point2=(0.04, 0.02))
	mdb.models['Model-1'].Part(dimensionality=THREE_D, name='pipe', type=DEFORMABLE_BODY)
	mdb.models['Model-1'].parts['pipe'].BaseSolidExtrude(depth=pipe_t, sketch=
		mdb.models['Model-1'].sketches['__profile__'])
	del mdb.models['Model-1'].sketches['__profile__']

	## Define PART cell, surfaces and edges for reference
	part_top_face = mdb.models['Model-1'].parts['pipe'].faces.findAt((0.013333, 0.006667, pipe_t), )
	part_front_face = mdb.models['Model-1'].parts['pipe'].faces.findAt((0.01, 0.0, 0.005), )
	part_top_right_edge = mdb.models['Model-1'].parts['pipe'].edges.findAt((0.04, 0.015, pipe_t), )
	part_front_right_edge = mdb.models['Model-1'].parts['pipe'].edges.findAt((0.04, 0.0, 0.003), )
	part_whole_cell = mdb.models['Model-1'].parts['pipe'].cells.findAt(((0.019022, 0.000405, pipe_t), ))

	## Define Datum points and axes globally
	mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, pipe_t - current_depth))
	mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, pipe_t - current_depth + part_in))
	mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, pipe_t - current_depth - part_in))
	mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, pipe_t - current_depth))
	mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=XAXIS)
	mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=YAXIS)
	mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=ZAXIS)
	datum_y = mdb.models['Model-1'].parts['pipe'].datums[7]
	datum_z = mdb.models['Model-1'].parts['pipe'].datums[8]

	## Partition the body into three regions
	mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.002, name='__profile__',
		sheetSize=0.097, transform=
		mdb.models['Model-1'].parts['pipe'].MakeSketchTransform(
		sketchPlane=part_top_face, sketchPlaneSide=SIDE1,
		sketchUpEdge=part_top_right_edge, sketchOrientation=RIGHT, origin=(0.02, 0.01, 0.012)))
	mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(
		decimalPlaces=3)
	mdb.models['Model-1'].parts['pipe'].projectReferencesOntoSketch(filter=
		COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
	mdb.models['Model-1'].sketches['__profile__'].ArcByCenterEnds(center=(0.0,
		-0.01), direction=CLOCKWISE, point1=(-probe_radius, -0.01), point2=(probe_radius,
		-0.01))
	mdb.models['Model-1'].sketches['__profile__'].ArcByCenterEnds(center=(0.0,
		-0.01), direction=CLOCKWISE, point1=(-0.014, -0.01), point2=(0.014, -0.01))
	mdb.models['Model-1'].parts['pipe'].PartitionFaceBySketch(faces=part_top_face,
		sketch=mdb.models['Model-1'].sketches['__profile__'], sketchUpEdge=part_top_right_edge)
	del mdb.models['Model-1'].sketches['__profile__']
	mdb.models['Model-1'].parts['pipe'].PartitionCellByExtrudeEdge(cells=part_whole_cell,
		edges=(mdb.models['Model-1'].parts['pipe'].edges.findAt((
		0.010101, 0.009899, pipe_t), ), ), line=datum_z, sense=REVERSE)
	mdb.models['Model-1'].parts['pipe'].PartitionCellByExtrudeEdge(cells=
		mdb.models['Model-1'].parts['pipe'].cells.findAt(((0.02, 0.0001, 0.005), )),
		edges=(mdb.models['Model-1'].parts['pipe'].edges.findAt((
		0.02, probe_radius, pipe_t), ), ), line=datum_z, sense=REVERSE)

	# Revolve cut of the center cell
	mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.001, name='__profile__',sheetSize=0.044, transform=
		mdb.models['Model-1'].parts['pipe'].MakeSketchTransform(
		sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.021058,0.0,0.00967), ),
		sketchPlaneSide=SIDE1,sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.02+probe_radius,0.0,0.01025), ),
		sketchOrientation=RIGHT, origin=(0.02, 0.0, pipe_t/2)))
	mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(decimalPlaces=3)
	mdb.models['Model-1'].parts['pipe'].projectReferencesOntoSketch(filter=
		COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
	mdb.models['Model-1'].sketches['__profile__'].ConstructionLine(point1=(0.0, pipe_t/2 - current_depth),
		point2=(-math.tan(current_angle), pipe_t/2 - current_depth + 1))

	# Save the construction line
	const_line = mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
		(math.tan(current_angle), pipe_t/2 - current_depth - 1))

	mdb.models['Model-1'].sketches['__profile__'].EllipseByCenterPerimeter(
		axisPoint1=(-current_short_axis * math.sin(current_angle),
		current_short_axis * math.cos(current_angle) + pipe_t/2 - current_depth),
		axisPoint2=(current_long_axis * math.cos(current_angle),
		current_long_axis * math.sin(current_angle) + pipe_t/2 - current_depth), center=(0.0, pipe_t/2 - current_depth))
	mdb.models['Model-1'].sketches['__profile__'].breakCurve(
		curve1=mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
		(current_long_axis * math.cos(current_angle),
		 current_long_axis * math.sin(current_angle) + pipe_t/2 - current_depth)),
		curve2=const_line,
		point1=(current_long_axis * math.cos(current_angle),
		current_long_axis * math.sin(current_angle) + pipe_t/2 - current_depth),
		point2=(0.01 * math.tan(current_angle), pipe_t/2 - current_depth - 0.01))
	mdb.models['Model-1'].sketches['__profile__'].delete(objectList=(
		mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((-current_long_axis * math.cos(current_angle),
		-current_long_axis * math.sin(current_angle) + pipe_t/2 - current_depth), ),))
	mdb.models['Model-1'].sketches['__profile__'].Line(
		point1=(-current_short_axis * math.sin(current_angle),
		current_short_axis * math.cos(current_angle) + pipe_t/2 - current_depth),
		point2=(current_short_axis * math.sin(current_angle),
		-current_short_axis * math.cos(current_angle) + pipe_t/2 - current_depth))
	mdb.models['Model-1'].sketches['__profile__'].PerpendicularConstraint(
		addUndoState=False, entity1=
		mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((0.0, pipe_t/2 - current_depth), ),
		entity2=mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
		(current_long_axis * math.cos(current_angle),
		current_long_axis * math.sin(current_angle) + pipe_t/2 - current_depth), ))
	mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(constructionGeometry=ON)
	mdb.models['Model-1'].sketches['__profile__'].assignCenterline(line=const_line)
	mdb.models['Model-1'].parts['pipe'].CutRevolve(angle=180.0,flipRevolveDirection=OFF, sketch=
		mdb.models['Model-1'].sketches['__profile__'],sketchOrientation=RIGHT,
		sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.02, 0.0, 0.01), ),
		sketchPlaneSide=SIDE1, sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.02+probe_radius, 0.0, 0.01),))
	del mdb.models['Model-1'].sketches['__profile__']

	# Create a perpendicular construction line in the PART module
	# const_line = mdb.models['Model-1'].parts['pipe'].datums[12]
	# mdb.models['Model-1'].parts['pipe'].DatumAxisByRotation(angle=90.0, axis=datum_y, line=const_line)

	## Material properties and instance
	mdb.models['Model-1'].Material(name='HDPE')
	mdb.models['Model-1'].materials['HDPE'].Density(table=((mat_density,),))
	mdb.models['Model-1'].materials['HDPE'].Elastic(table=((young_modulus, poisson_ratio),))
	mdb.models['Model-1'].HomogeneousSolidSection(material='HDPE', name='Section-1', thickness=None)
	mdb.models['Model-1'].parts['pipe'].SectionAssignment(offset=0.0, offsetField='', offsetType=MIDDLE_SURFACE,
		region=Region(cells=mdb.models['Model-1'].parts['pipe'].cells.findAt(
		((0.030275,0.001038, 0.0),), ((0.013333, 0.02, 0.0),), ((0.02, 0.0001, 0.0),), )),
		sectionName='Section-1',thicknessAssignment=FROM_SECTION)
	mdb.models['Model-1'].rootAssembly.DatumCsysByDefault(CARTESIAN)
	if current_index == 1:
		mdb.models['Model-1'].rootAssembly.Instance(dependent=OFF, name='pipe-1',
			part=mdb.models['Model-1'].parts['pipe'])
	else:
		del mdb.models['Model-1'].rootAssembly.instances['pipe-1']
		mdb.models['Model-1'].rootAssembly.Instance(dependent=OFF, name='pipe-1',
			part=mdb.models['Model-1'].parts['pipe'])

	## Save construction line in the global assembly
	const_line = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[12]
	# const_line2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[13]
	datum_pt1 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[2]
	datum_pt2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[3]
	datum_pt3 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[4]
	datum_pt4 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[5]
	datum_x = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[6]
	datum_y = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[7]
	datum_z = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[8]

	# Create set for the symmetry plane
	mdb.models['Model-1'].rootAssembly.Set(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(
		((0.001, 0.0, 0.003),), ((0.007, 0.0, 0.003),), ((0.021, 0.0, 0.003),),
		((0.03, 0.0, 0.003),), ((0.038, 0.0, 0.003),),), name='sym_plane')

	# Create surface for the exciter
	mdb.models['Model-1'].rootAssembly.Surface(name='exciter',
		side1Faces=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((0.02, 0.001, pipe_t), )))

	# Create set for center region before meshing
	mdb.models['Model-1'].rootAssembly.Set(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((0.02, 0.001, 0.001),),), name='center')

	## Partition middle region cell
	mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0201-probe_radius, 0.00001, datum_pt2.pointOn[2] + 0.0001),)),normal=datum_z, point=datum_pt2)

	mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0201-probe_radius, 0.00001, datum_pt3.pointOn[2] - 0.0001),)), normal=datum_z, point=datum_pt3)

	# Partition the top region
	mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0201-probe_radius, 0.00001, datum_pt2.pointOn[2] + 0.0001),)), normal=datum_x, point=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		(0.02, 0.0, pipe_t), ), MIDDLE))

	mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0201-probe_radius, 0.00001, datum_pt3.pointOn[2] - 0.0001),)), normal=datum_x, point=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			(0.02, 0.0, 0.0), ), MIDDLE))

	## Create a big test sensor set
	mdb.models['Model-1'].rootAssembly.Set(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((0.021, 0.001, pipe_t), ),
		((0.019, 0.001, pipe_t), )), name='sensor_all')

	## Assign seeds
	# Global seed
	mdb.models['Model-1'].rootAssembly.seedPartInstance(deviationFactor=0.1,minSizeFactor=0.8, regions=(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'],), size=mesh_size_general)

	# Single biased seed for connection regions
	mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end1Edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.01, 0.0, 0.0),),
		((0.01, 0.0, pipe_t),), ), maxSize=mesh_size_coarse/2, minSize=mesh_size_general)
	mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end2Edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.03, 0.0, 0.0),),
		((0.03, 0.0, pipe_t),), ), maxSize=mesh_size_coarse/2, minSize=mesh_size_general)

	# Seed for edges parallel to z axis
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE,deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.0, 0.0, 0.001),), ((0.006, 0.0, 0.001),), ((0.034, 0.0, 0.001),), ((0.04, 0.0, 0.001),)),
		minSizeFactor=0.1, size=mesh_size_general)

	# Seed for connection region, two semi-circles
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.02, 0.014, 0.0),), ((0.02, 0.014, pipe_t),)),
		minSizeFactor=0.1, size=mesh_size_coarse)

	# Seed for out region
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.001, 0.0, 0.0),), ((0.039, 0.0, 0.0),), ((0.0, 0.01, 0.0),), ((0.04, 0.01, 0.0),), ((0.02, 0.02, 0.0),)),
		minSizeFactor=0.1, size=mesh_size_coarse)

	# Seed the center region, fix the seed number
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FIXED, deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.019, 0.0, datum_pt2.pointOn[2]),), ((0.021, 0.0, datum_pt2.pointOn[2]),)),
		minSizeFactor=0.8, size=mesh_size_general)

	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FIXED, deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.019, 0.0, datum_pt3.pointOn[2]),), ((0.021, 0.0, datum_pt3.pointOn[2]),)),
		minSizeFactor=0.8, size=mesh_size_general)

	# Seed the crack perimeter
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
	mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.02 + current_long_axis * math.cos(current_angle), 0.0,
		  pipe_t - current_depth + current_long_axis * math.sin(current_angle)),),
		((0.02 - current_long_axis * math.cos(current_angle), 0.0,
		  pipe_t - current_depth - current_long_axis * math.sin(current_angle)),)),minSizeFactor=0.8, size=mesh_size_fine)

	# Partition the ellip crack face for better meshing result
	mdb.models['Model-1'].rootAssembly.PartitionFaceByShortestPath(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
		0.02, current_long_axis, pipe_t - current_depth),)), point1=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
		0.02 + current_long_axis * math.cos(current_angle), 0.0, pipe_t - current_depth + current_long_axis * math.sin(current_angle)), ),
		MIDDLE), point2=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
		0.02 - current_long_axis * math.cos(current_angle), 0.0, pipe_t - current_depth - current_long_axis * math.sin(current_angle)), ), MIDDLE))

	# Seed the crack perimeter
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.02, current_long_axis, pipe_t - current_depth),)),
		minSizeFactor=0.8, size=mesh_size_fine)

	# Set Tet element type for the crack region
	mdb.models['Model-1'].rootAssembly.setMeshControls(elemShape=TET, regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((0.02,
		0.002, datum_pt2.pointOn[2] - 0.0001),)), sizeGrowthRate=1.03,technique=FREE)

	mdb.models['Model-1'].rootAssembly.setElementType(elemTypes=(ElemType(
		elemCode=UNKNOWN_HEX, elemLibrary=EXPLICIT), ElemType(
		elemCode=UNKNOWN_WEDGE, elemLibrary=EXPLICIT), ElemType(elemCode=C3D10M,
		elemLibrary=EXPLICIT, secondOrderAccuracy=OFF,distortionControl=DEFAULT)),
		regions=(mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.02, 0.002, datum_pt2.pointOn[2] - 0.0001),)),))

	## Mesh
	# Mesh the center region except the crack partition
	mdb.models['Model-1'].rootAssembly.generateMesh(regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0201-probe_radius, 0.00001, datum_pt2.pointOn[2] + 0.0001),),
		((0.0199+probe_radius, 0.00001, datum_pt2.pointOn[2] + 0.0001),),
		((0.0201-probe_radius, 0.00001, datum_pt3.pointOn[2] - 0.0001),),
		((0.0199+probe_radius, 0.00001, datum_pt3.pointOn[2] - 0.0001),)))

	# Mesh the connection region
	mdb.models['Model-1'].rootAssembly.generateMesh(regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.01, 0.001, 0.003),)))

	# Mesh the out region
	mdb.models['Model-1'].rootAssembly.generateMesh(regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.001, 0.001, 0.003),)))

	# Mesh the crack region
	mdb.models['Model-1'].rootAssembly.generateMesh(regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.02, 0.002, datum_pt2.pointOn[2] - 0.0001),)))

	## Create steps and outputs
	mdb.models['Model-1'].ExplicitDynamicsStep(name='Step-1', nlgeom=OFF, previous='Initial',
		timeIncrementationMethod=FIXED_USER_DEFINED_INC, timePeriod=total_time, userDefinedInc=time_increment)
	mdb.models['Model-1'].fieldOutputRequests['F-Output-1'].suppress()
	mdb.models['Model-1'].historyOutputRequests['H-Output-1'].setValues(frequency=1, rebar=EXCLUDE,
		region=mdb.models['Model-1'].rootAssembly.sets['sensor_all'],sectionPoints=DEFAULT, variables=('U3',))

	## Create load and BC
	# 2.5 cycles
	mdb.models['Model-1'].TabularAmplitude(data=((0.0, 0.0), (
    2.5e-08, 0.00194897732422402), (5e-08, 0.00749936469779943), (7.5e-08,
    0.0157821751620511), (1e-07, 0.0254167565564769), (1.25e-07,
    0.0346082692225902), (1.5e-07, 0.0412763459590382), (1.75e-07,
    0.0432076140126375), (2e-07, 0.038223337957104), (2.25e-07,
    0.0243524776957952), (2.5e-07, 1.16943363265131e-17), (2.75e-07,
    -0.0358996381001867), (3e-07, -0.0837533001355521), (3.25e-07,
    -0.143212617023721), (3.5e-07, -0.213116831660765), (3.75e-07,
    -0.291479843409094), (4e-07, -0.375524011195478), (4.25e-07,
    -0.461760857512023), (4.5e-07, -0.546116346548657), (4.75e-07,
    -0.624096012021681), (5e-07, -0.690983005625053), (5.25e-07,
    -0.74206023861849), (5.5e-07, -0.772846296026448), (5.75e-07,
    -0.779333795384948), (6e-07, -0.758218396990101), (6.25e-07,
    -0.707106781186548), (6.5e-07, -0.624692593655586), (6.75e-07,
    -0.510890597079379), (7e-07, -0.366921005010254), (7.25e-07,
    -0.195338134499781), (7.5e-07, -2.40462520828615e-16), (7.75e-07,
    0.214021832507633), (8e-07, 0.44059003132148), (8.25e-07,
    0.672702090996347), (8.5e-07, 0.90273634016427), (8.75e-07,
    1.122733718964), (9e-07, 1.32470383470392), (9.25e-07, 1.5009424616851), (
    9.5e-07, 1.64434687957902), (9.75e-07, 1.74871528675894), (1e-06,
    1.80901699437495), (1.025e-06, 1.82162118825236), (1.05e-06,
    1.78447369462384), (1.075e-06, 1.69721333119772), (1.1e-06,
    1.56122197242876), (1.125e-06, 1.37960529315051), (1.15e-06,
    1.15710415002271), (1.175e-06, 0.89993957958565), (1.2e-06,
    0.615597297450343), (1.225e-06, 0.31256024239776), (1.25e-06,
    6.12323399573677e-16), (1.275e-06, -0.312560242397761), (1.3e-06,
    -0.615597297450346), (1.325e-06, -0.899939579585651), (1.35e-06,
    -1.15710415002271), (1.375e-06, -1.3796052931505), (1.4e-06,
    -1.56122197242876), (1.425e-06, -1.69721333119772), (1.45e-06,
    -1.78447369462384), (1.475e-06, -1.82162118825236), (1.5e-06,
    -1.80901699437495), (1.525e-06, -1.74871528675894), (1.55e-06,
    -1.64434687957902), (1.575e-06, -1.5009424616851), (1.6e-06,
    -1.32470383470392), (1.625e-06, -1.122733718964), (1.65e-06,
    -0.902736340164271), (1.675e-06, -0.672702090996346), (1.7e-06,
    -0.440590031321481), (1.725e-06, -0.214021832507635), (1.75e-06,
    -5.61079215266769e-16), (1.775e-06, 0.195338134499779), (1.8e-06,
    0.366921005010254), (1.825e-06, 0.510890597079379), (1.85e-06,
    0.624692593655586), (1.875e-06, 0.707106781186547), (1.9e-06,
    0.758218396990101), (1.925e-06, 0.779333795384948), (1.95e-06,
    0.772846296026448), (1.975e-06, 0.74206023861849), (2e-06,
    0.690983005625053), (2.025e-06, 0.624096012021681), (2.05e-06,
    0.546116346548657), (2.075e-06, 0.461760857512022), (2.1e-06,
    0.375524011195478), (2.125e-06, 0.291479843409095), (2.15e-06,
    0.213116831660765), (2.175e-06, 0.143212617023721), (2.2e-06,
    0.0837533001355522), (2.225e-06, 0.0358996381001871), (2.25e-06,
    1.05249026938618e-16), (2.275e-06, -0.0243524776957951), (2.3e-06,
    -0.0382233379571039), (2.325e-06, -0.0432076140126374), (2.35e-06,
    -0.0412763459590381), (2.375e-06, -0.0346082692225902), (2.4e-06,
    -0.0254167565564767), (2.425e-06, -0.015782175162051), (2.45e-06,
    -0.00749936469779942), (2.475e-06, -0.00194897732422402), (2.5e-06, 0.0)),
    name='cos_2_5', smooth=SOLVER_DEFAULT, timeSpan=STEP)

	# 3 cycles
	mdb.models['Model-1'].TabularAmplitude(data=((0.0, 0.0), (3e-08,
    0.00193831950713421), (6e-08, 0.00733156530200401), (9e-08,
    0.0149553688471836), (1.2e-07, 0.0229018899099815), (1.5e-07,
    0.0287682579175257), (1.8e-07, 0.0298997180897102), (2.1e-07,
    0.0236685495833722), (2.4e-07, 0.00776676782235138), (2.7e-07,
    -0.0195108844724957), (3e-07, -0.0590169943749475), (3.3e-07,
    -0.110556088450452), (3.6e-07, -0.172761898856107), (3.9e-07,
    -0.243060632353894), (4.2e-07, -0.317727779806876), (4.5e-07,
    -0.392039521920206), (4.8e-07, -0.460513060657597), (5.1e-07,
    -0.517223685156237), (5.4e-07, -0.556180508961424), (5.7e-07,
    -0.57173799851997), (6e-07, -0.559016994374947), (6.3e-07,
    -0.514307163396255), (6.6e-07, -0.435422865745577), (6.9e-07,
    -0.321986312142294), (7.2e-07, -0.175615544492801), (7.5e-07,
    -1.83697019872103e-16), (7.8e-07, 0.199147084678648), (8.1e-07,
    0.414262793227062), (8.4e-07, 0.636230724212417), (8.7e-07,
    0.854787048461122), (9e-07, 1.05901699437495), (9.3e-07, 1.23791610641207),
    (9.6e-07, 1.38098581329584), (9.9e-07, 1.47882977170031), (1.02e-06,
    1.52371634197136), (1.05e-06, 1.5100735106701), (1.08e-06,
    1.43488558028085), (1.11e-06, 1.29796585319769), (1.14e-06,
    1.10208608064127), (1.17e-06, 0.852951259752979), (1.2e-06,
    0.559016994374945), (1.23e-06, 0.231155582656112), (1.26e-06,
    -0.117814271236274), (1.29e-06, -0.473711224746337), (1.32e-06,
    -0.821658865040433), (1.35e-06, -1.14680224666742), (1.38e-06,
    -1.43503536493284), (1.41e-06, -1.67370048215685), (1.44e-06,
    -1.8522214064745), (1.47e-06, -1.96263618195024), (1.5e-06, -2.0), (
    1.53e-06, -1.96263618195024), (1.56e-06, -1.8522214064745), (1.59e-06,
    -1.67370048215685), (1.62e-06, -1.43503536493284), (1.65e-06,
    -1.14680224666742), (1.68e-06, -0.821658865040435), (1.71e-06,
    -0.473711224746339), (1.74e-06, -0.117814271236276), (1.77e-06,
    0.231155582656114), (1.8e-06, 0.559016994374947), (1.83e-06,
    0.852951259752976), (1.86e-06, 1.10208608064127), (1.89e-06,
    1.29796585319769), (1.92e-06, 1.43488558028085), (1.95e-06,
    1.5100735106701), (1.98e-06, 1.52371634197136), (2.01e-06,
    1.47882977170031), (2.04e-06, 1.38098581329584), (2.07e-06,
    1.23791610641207), (2.1e-06, 1.05901699437495), (2.13e-06,
    0.854787048461122), (2.16e-06, 0.636230724212416), (2.19e-06,
    0.41426279322706), (2.22e-06, 0.199147084678649), (2.25e-06,
    5.51091059616309e-16), (2.28e-06, -0.1756155444928), (2.31e-06,
    -0.321986312142293), (2.34e-06, -0.435422865745577), (2.37e-06,
    -0.514307163396256), (2.4e-06, -0.559016994374948), (2.43e-06,
    -0.571737998519971), (2.46e-06, -0.556180508961424), (2.49e-06,
    -0.517223685156238), (2.52e-06, -0.460513060657597), (2.55e-06,
    -0.392039521920206), (2.58e-06, -0.317727779806875), (2.61e-06,
    -0.243060632353894), (2.64e-06, -0.172761898856108), (2.67e-06,
    -0.110556088450452), (2.7e-06, -0.0590169943749476), (2.73e-06,
    -0.019510884472496), (2.76e-06, 0.00776676782235151), (2.79e-06,
    0.0236685495833723), (2.82e-06, 0.0298997180897102), (2.85e-06,
    0.0287682579175258), (2.88e-06, 0.0229018899099815), (2.91e-06,
    0.0149553688471836), (2.94e-06, 0.00733156530200412), (2.97e-06,
    0.00193831950713421), (3e-06, 0.0)),
    name='cos_3', smooth=SOLVER_DEFAULT, timeSpan=STEP)

	# 2 cycles
	mdb.models['Model-1'].TabularAmplitude(data=((0.0, 0.0), (2e-08,
    0.00195771173599771), (4e-08, 0.00763756752726646), (6e-08,
    0.0164688977728995), (8e-08, 0.0275307857688423), (1e-07,
    0.0395961100811341), (1.2e-07, 0.0511907386947495), (1.4e-07,
    0.0606655199332525), (1.6e-07, 0.0662781951924082), (1.8e-07,
    0.0662819455962172), (2e-07, 0.0590169943749474), (2.2e-07,
    0.0430015302486876), (2.4e-07, 0.0170182006929525), (2.6e-07,
    -0.019807451105763), (2.8e-07, -0.0679399694381377), (3e-07,
    -0.127381362373607), (3.2e-07, -0.197635338397332), (3.4e-07,
    -0.277690267815718), (3.6e-07, -0.366022054966911), (3.8e-07,
    -0.460617377530741), (4e-07, -0.559016994374947), (4.2e-07,
    -0.658378070661947), (4.4e-07, -0.755553745691616), (4.6e-07,
    -0.847187501568444), (4.8e-07, -0.929819303786272), (5e-07, -1.0), (
    5.2e-07, -1.05441009884268), (5.4e-07, -1.08997882068882), (5.6e-07,
    -1.10399922608489), (5.8e-07, -1.09423528942578), (6e-07,
    -1.05901699437495), (6.2e-07, -0.997319877312082), (6.4e-07,
    -0.90882592453047), (6.6e-07, -0.793963322142275), (6.8e-07,
    -0.653923244732814), (7e-07, -0.490652626376287), (7.2e-07,
    -0.306822659733312), (7.4e-07, -0.105773587952863), (7.6e-07,
    0.108562838365675), (7.8e-07, 0.331761098922761), (8e-07,
    0.559016994374947), (8.2e-07, 0.785276637533928), (8.4e-07,
    1.00537539476559), (8.6e-07, 1.21418245956413), (8.8e-07,
    1.40674651614807), (9e-07, 1.57843787866876), (9.2e-07, 1.72508257431889),
    (9.4e-07, 1.8430840740036), (9.6e-07, 1.92952875473), (9.8e-07,
    1.98227169089296), (1e-06, 2.0), (1.02e-06, 1.98227169089296), (1.04e-06,
    1.92952875473), (1.06e-06, 1.8430840740036), (1.08e-06, 1.72508257431888),
    (1.1e-06, 1.57843787866876), (1.12e-06, 1.40674651614807), (1.14e-06,
    1.21418245956413), (1.16e-06, 1.00537539476559), (1.18e-06,
    0.785276637533929), (1.2e-06, 0.559016994374945), (1.22e-06,
    0.33176109892276), (1.24e-06, 0.108562838365674), (1.26e-06,
    -0.105773587952863), (1.28e-06, -0.306822659733309), (1.3e-06,
    -0.490652626376287), (1.32e-06, -0.653923244732812), (1.34e-06,
    -0.793963322142273), (1.36e-06, -0.908825924530468), (1.38e-06,
    -0.997319877312083), (1.4e-06, -1.05901699437495), (1.42e-06,
    -1.09423528942578), (1.44e-06, -1.10399922608489), (1.46e-06,
    -1.08997882068882), (1.48e-06, -1.05441009884268), (1.5e-06, -1.0), (
    1.52e-06, -0.929819303786272), (1.54e-06, -0.847187501568446), (1.56e-06,
    -0.755553745691616), (1.58e-06, -0.658378070661948), (1.6e-06,
    -0.559016994374948), (1.62e-06, -0.46061737753074), (1.64e-06,
    -0.366022054966911), (1.66e-06, -0.277690267815718), (1.68e-06,
    -0.197635338397332), (1.7e-06, -0.127381362373607), (1.72e-06,
    -0.0679399694381382), (1.74e-06, -0.0198074511057631), (1.76e-06,
    0.0170182006929527), (1.78e-06, 0.0430015302486874), (1.8e-06,
    0.0590169943749474), (1.82e-06, 0.0662819455962172), (1.84e-06,
    0.0662781951924081), (1.86e-06, 0.0606655199332526), (1.88e-06,
    0.0511907386947495), (1.9e-06, 0.0395961100811341), (1.92e-06,
    0.0275307857688422), (1.94e-06, 0.0164688977728994), (1.96e-06,
    0.00763756752726657), (1.98e-06, 0.00195771173599771), (2e-06, 0.0)), name='cos_2', smooth=SOLVER_DEFAULT,
    timeSpan=STEP)
	mdb.models['Model-1'].Pressure(amplitude='cos_2_5', createStepName='Step-1',
		distributionType=UNIFORM, field='', magnitude=1000000.0, name='Load-1',
		region=mdb.models['Model-1'].rootAssembly.surfaces['exciter'])
	mdb.models['Model-1'].YsymmBC(createStepName='Step-1', localCsys=None, name=
		'BC-1', region=mdb.models['Model-1'].rootAssembly.sets['sym_plane'])
	mdb.Job(activateLoadBalancing=False, atTime=None, contactPrint=OFF, 
		description='', echoPrint=OFF, explicitPrecision=DOUBLE, historyPrint=OFF, 
		memory=90, memoryUnits=PERCENTAGE, model='Model-1', modelPrint=OFF, 
		multiprocessingMode=DEFAULT, name='Ellip_HDPE_'+str(current_index), nodalOutputPrecision=FULL,
		numCpus=16, numDomains=16, parallelizationMethodExplicit=DOMAIN, queue=None
		, resultsFormat=ODB, scratch='', type=ANALYSIS, userSubroutine='', 
		waitHours=0, waitMinutes=0)
	break
	mdb.jobs['Ellip_HDPE_'+str(current_index)].submit(consistencyChecking=OFF)
	mdb.jobs['Ellip_HDPE_'+str(current_index)].waitForCompletion()

	# Open ODB file after the job is finished
	Odb_path = 'Ellip_HDPE_'+str(current_index)+'.odb'
	odb = openOdb(Odb_path)

	# Open history steps data
	step1 = odb.steps['Step-1']

	# Use a loop to get the U3 data of all the nodes
	set_sensor = odb.rootAssembly.nodeSets['SENSOR_ALL'].nodes[0]

	try:
		region = step1.historyRegions['Node PIPE-1.'+str(set_sensor[0].label)]
	except KeyError:
		odb.close()
		failure_flag = 1
		if trial_index == max_trial:
			failed_mesh.append(current_index)
		pass
	else:
		time, U3_total = zip(*step1.historyRegions['Node PIPE-1.' + str(set_sensor[0].label)].historyOutputs['U3'].data)
		for i in range(1,len(set_sensor)):
			time, U3 = zip(*step1.historyRegions['Node PIPE-1.' + str(set_sensor[i].label)].historyOutputs['U3'].data)
			U3_total = [a + b for a, b in zip(U3_total, U3)]

		U3_ave = [a / len(set_sensor) for a in U3_total]

		nn = len(U3_ave)
		if nn < sampling_number:
			odb.close()
			failure_flag = 1
			if trial_index == max_trial:
				failed_earlystop.append(current_index)
		else:
			for i in range(nn):
				sheet1.write_number(current_index - 1, i, U3_ave[i])

			sheet2.write_number(0, current_index - 1, current_short_axis * (crack_short_axis == True))
			sheet2.write_number(1, current_index - 1, current_long_axis * (crack_long_axis == True))
			sheet2.write_number(2, current_index - 1, current_depth * (crack_depth == True))
			sheet2.write_number(3, current_index - 1, current_angle / math.pi * 180.0 * (crack_orientation == True))
			odb.close()
			failure_flag = 0

	# Remove all the files after getting the data
	try:
		os.remove('Ellip_HDPE_' + str(current_index) + '.abq')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_HDPE_' + str(current_index) + '.mdl')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_HDPE_' + str(current_index) + '.pac')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_HDPE_' + str(current_index) + '.stt')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_HDPE_' + str(current_index) + '.inp')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_HDPE_' + str(current_index) + '.prt')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_HDPE_' + str(current_index) + '.res')
	except WindowsError:
		pass
	if remove_odb:
		try:
			os.remove('Ellip_HDPE_' + str(current_index) + '.odb')
		except WindowsError:
			pass

	if not failure_flag:
		trial_index = 0
		if current_index % space_number == 0:
			loop_index = loop_index + 1
		current_index = current_index + 1
	else:
		if trial_index == max_trial:
			trial_index = 0
			failure_flag = 0
			if current_index % space_number == 0:
				loop_index = loop_index + 1
			current_index = current_index + 1

"""Close the workbooks"""
wb1.close()
wb2.close()

# Write error message
len_fail_mesh = len(failed_mesh)
len_fail_earlystop = len(failed_earlystop)
with open('ellip_HDPE/Ellip_failed_simulation.txt', 'w') as f:
	for i in range(0, len_fail_mesh):
		f.write('%s, ' % failed_mesh[i])
	f.write('\nOut of '+str(num_of_simulation)+' simulations, '+str(len_fail_mesh)+' have failed due to mesh generation.')
	f.write('\n')
	for i in range(0, len_fail_earlystop):
		f.write('%s, ' % failed_earlystop[i])
	f.write('\nOut of '+str(num_of_simulation)+' simulations, '+str(len_fail_earlystop)+' have failed due to unexpected stop.')